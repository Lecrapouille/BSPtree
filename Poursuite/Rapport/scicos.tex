%%====================================================================
%%==================================================================== 
%\chapter{Logiciel de développement Scilab}
%\section{Présentation}
\section{Logiciel de modélisation et de simulation Scilab/Scicos}
%%====================================================================
%%==================================================================== 

\subsection{Différents types de logiciels scientifiques}
Il existe deux types de programmes scientifiques~: -- les logiciels
algébriques faisant essentiellement du calcul symbolique (Maple,
Mathematica, Maxima, Axiom, et MuPad), -- les logiciels de calcul
scientifique faisant essentiellement de l'analyse numérique (Scilab,
MATLAB).

Scilab \cite{Chancelier, Scilab} est un logiciel libre pour le calcul
scientifique.  Scilab est un interpréteur de langage manipulant des
objets typés dynamiquement. Il inclut de nombreuses fonctions
spécialisées pour le calcul numérique organisées sous forme de
librairies ou de boites à outils qui couvrent des domaines tels que la
simulation, l'optimisation, et le traitement du signal et du contrôle.

Une des boites à outils les plus importantes de Scilab est Scicos
\cite{Chancelier, Scicos}. Scicos est un éditeur graphique de bloc
diagramme permettant de modéliser et de simuler des systèmes
dynamiques. Il est particulièrement utilisé pour modéliser des
systèmes o\`u des composants temps-continu et temps-discret sont
inter-connectés (systèmes hybrides) comme le montre la figure (\ref{hybride}).

\dessin{figures/regulateur/hybride}{0.4}{Un système hybride.}{hybride}

Ce système est hybride car~: -- les blocs 3, 5 et 7 sont continus et -- les blocs 4, 6 et 2 sont discrets.

%%%==================================================================== 
%\subsection{De la simulation à l'implantation distribuée temps réel}\label{sss}
%%%==================================================================== 

%A FINIR !!!!!!

%Un système dynamique est généralement composé d'un \emph{processesus} et de son régulateur. Le processus peut être vu comme un modèle physique, par exemple d'une voiture ou un avion. Cette voiture ou avion, possède un certains nombres de capteurs et d'actuateurs qui lui permettent de réaliser certaines tâches comme tourner les roues, déplacer le véhicule, ... Un automate permet de\\[0.5cm]
%\begin{minipage}[b]{.45\linewidth}
%\centering\epsfig{figure=figures/syndex, width=\linewidth}
%\caption{Travail de Scicos.}\label{foo1}
%\end{minipage}\hspace{6mm}
%\begin{minipage}[b]{.45\linewidth}
%\centering\epsfig{figure=figures/syndex, width=\linewidth}
%\caption{Travail de SynDEx.}\label{foo2}
%\end{minipage}

%A gauche, les blocs \emph{processus}, \emph{régulateur}, \emph{capteurs} et \emph{actuateurs} sont modélisés avec le logiciel Scicos. Une fois que le système fonctionne en simulation (système stable, ...), on récupère les \emph{Régulateur}, \emph{capteurs} et \emph{actuateurs} on les passent dans le logiciel SynDEx, on en tire un graphe hiérarchique que l'on appelle \emph{algorithme}. On lui associe un graphe représentant l'architecture matérielle (micro-contrôleurs, FPGA, ...). SynDEx réalisera l'implantation distribuée temps réel.

%Un programme Scicos peut être traduit en un programme SynDEx grâce à
%un traducteur intégré dans l'IHM de Scilab, téléchargeable sur le site de SynDEx\cite{SynDEx}.

%%==================================================================== 
\subsection{Mise en place de nouveaux blocs Scicos}
%%==================================================================== 

Les blocs prédéfinis dans les palettes Scicos permettent de construire
des schémas très divers et de créer des systèmes dynamiques hybrides
mais dans certains cas on a besoin d'une fonctionnalité que Scicos ne possède pas.
Dans notre cas, nous avons besoin d'obtenir des images à partir d'une caméra FireWire.
Ces blocs peuvent être définis de plusieurs façons (Scilab, C, Fortran), mais dans tous les cas,
Scicos a besoin de deux types de fonctions~: -- une fonction d'interface, presque toujours écrite en Scilab, pour gérer l'interface avec l'éditeur Scicos,  -- une fonction de simulation réalisant le
comportement dynamique du bloc.

%\begin{moncadre}
Pour ce stage,  j'ai construit de nouveaux blocs permettant d'obtenir des images à partir d'une caméra FireWire et de quelques filtres. J'explique ici comment créer les fonctions d'interface et de simulation, qui servent de patron--exemple pour créer d'autres blocs Scicos.
%\end{moncadre} 

%%==================================================================== 
\subsubsection*{La fonction d'interface}
%%==================================================================== 

La fonction d'interface d'un bloc détermine non seulement sa
géométrie, sa couleur, le nombre et la taille de ses ports
d'entrée-sorties, etc., mais aussi les états initiaux et ses paramètres.
Elle gère une fenêtre de dialogue qui permet de ses propriétés, ce que
l'utilisateur peut faire en cliquant sur le bloc.

Les fonctions d'interface suivent à peu près toujours le même patron~:
\begin{verbatim}
// Fichier: CAMERA_FIREWIRE.sci

function [x,y,typ]=CAMERA_FIREWIRE(job,arg1,arg2)
x=[];y=[];typ=[]
select job

case 'plot' then
  standard_draw(arg1)
case 'getinputs' then
  [x,y,typ]=standard_inputs(o)
case 'getoutputs' then
  [x,y,typ]=standard_outputs(o)
case 'getorigin' then
  [x,y]=standard_origin(arg1)

case 'set' then
  x=arg1;
  graphics=arg1.graphics;
  exprs=graphics.exprs;
  model=arg1.model;
  while %t do
    [ok,height,width,exprs]=getvalue(..
	['Camera FireWire (IEEE 1394)';
	 '';
	 'Donne une image RGB de taille sous';
         'forme de vecteur de taille 3 x height x width'],..
	['Height';
	'Width'],..
	 list('vec',1,'vec',1),exprs)
    if ~ok then break,end //user cancel modification
    graphics.exprs=exprs;
    if ok then
        model.ipar=[height,width]
        graphics.exprs=exprs;
        x.graphics=graphics;
        model.out = 3 * height * width;
        x.model=model;
        break
    end
  end

case 'define' then
  height = 240
  width  = 320
  model  = scicos_model()
  model.sim = list('scicos_camerafirewire',4)
  model.evtin = 1;
  model.out = 3 * 240 * 320;
  model.ipar=[height,width]
  model.blocktype='d'
  model.dep_ut=[%f %t]
  exprs=[string(height); string(width)]
  gr_i=['txt=[''Camera'';''FireWire''];';
    'xstringb(orig(1),orig(2),txt,sz(1),sz(2),''fill'')']
  x=standard_define([4 2],model,exprs,gr_i)
end
endfunction
\end{verbatim}

La figure (\ref{scicoscam}) montre ce que l'on peut obtenir après compilation. Selon la valeur de {\tt job}~: 
\dessin{figures/regulateur/scicos_camera}{0.5}{La fonction d'interface obtenue après compilation.}{scicoscam}

On a utilisé ici les fonctions standard pour dessiner un bloc
rectangulaire avec les cas {\tt plot} (dessiner le bloc), {\tt
  getinputs}, {\tt getoutputs} (retourner les coordonnées des entrées
et des sorties).

Les cas {\tt define} et {\tt set} doivent être adaptés. Le premier
définit les valeurs initiales des paramètres et le deuxième gère la
fenêtre de dialogue avec l'utilisateur. Les variables {\tt graphics}
et {\tt model} sont des structures représentées sous forme de
liste. {\tt graphics} contient des informations sur l'aspect du bloc,
comme sa taille, son emplacement, ... et {\tt model} des informations
nécessaires pour la simulation comme le nom de la fonction de
simulation et son type, le nombre et les tailles de ports
d'entrées-sorties, les valeurs des états, des paramètres, etc.

Dans le cas {\tt define}, nous créons deux variables {\tt height} et
{\tt width} qui définissent la taille par défaut de l'image. {\tt
  model.out} est le port de sortie qui est un vecteur de taille
$3\times240\times320$. Nous avons aucune entrée {\tt model.in} car
nous définissons un capteur. {\tt model.evtin} indique que nous avons
qu'une entrée d'horloge. {\tt model.blocktype} indique que nous avons
un bloc de type discret. L'élément {\tt [\%f \%t]} indique que ce bloc
ne contient pas de dépendance directe d'entré-sortie, mais qu'il est
temps dépendant.

Dans le cas {\tt set}, nous créons une liste de dialogue qui permet à
l'utilisateur de modifier les variables {\tt height} et {\tt
  width}. Les valeurs de ces deux variables seront affichées, ainsi
qu'un titre. Lorsqu'on clique sur le bouton {\tt ok} on change la
taille du port de sortie en fonction des nouvelles valeurs de {\tt
  height} et {\tt width}.
%%==================================================================== 
\subsubsection*{La fonction de simulation}
%%==================================================================== 
Le patron de la fonction de simulation en langage C est plus simple
que pour le patron de la fonction d'interface. En effet elle effectue
les tâches suivantes selon la valeur d'un paramètre {\tt flag}~:
\begin{itemize}
\item[$\bullet$] \emph{initialisation}~: Scicos appelle ce cas une
  seule fois et au tout début de la simulation pour lui permettre
  d'initialiser ses états initiaux ou ouvrir un le port de la caméra.
\item[$\bullet$] \emph{terminaison}~: Scicos appelle ce cas une seule
  fois et à la fin de la simulation pour lui permettre par exemple de
  libèrer de la mémoire ou de fermer le port de la caméra.
\item[$\bullet$] \emph{calcul des sorties}~: la fonction calcule ses
  sorties en fonction des valeurs de ses entrées et de ses états.
\item[$\bullet$] Il existe d'autres cas comme, la mise à jour des
  états, calcul des dates des événements de sortie, calcul de la
  dérivée de l'état continu, ...
\end{itemize}

\begin{verbatim}
/* Fichier: scicos_camera_firewire.c */

#  include <scicos/scicos_block.h>

void		scicos_camera_firewire(scicos_block *block, int flag)
{
  switch (flag)
    {
    case INITIALISATION:
      camera_firewire_open();
      break;
    case TERMINAISON:
      camera_firewire_close();
      break;
    case CALCUL_DES_SORTIES:
      camera_firewire_get_new_image(block);
      break;
    default: break;
    }
}
\end{verbatim}

La valeur de {\tt flag} est mise à jour par Scicos. J'ai caché la
valeur des identifiants des tâches en utilisant des {\tt define} même si
les développeurs de Scicos préfèrent manipuler directement la valeur
littérale de {\tt flag}.

\begin{verbatim}
#define CALCUL_DES_SORTIES      1
#define INITIALISATION          4
#define TERMINAISON             5
\end{verbatim}

On fera attention, au bouton {\tt stop} du menu Scicos qui ne termine
pas la simulation, mais la met en pause. Par conséquent la fonction
{\tt camera\_firewire\_close} sera appelée que si on clique ensuite
sur le bouton {\tt restart}.

Nous n'avons pas encore parler de la structure {\tt
  scicos\_block}. Elle contient toutes les informations utiles du
blocs, comme les port d'entrées, sorties, les paramètres, les états~:
\begin{verbatim}
typedef struct {
int nevprt; /* binary coding of activation inputs, -1 if internal ly activated */
voidg funpt; /* pointer: pointer to the computational function */
int type; /* type of interfacing function, current type is 4 */
int scsptr; /* not used for C interfacing functions */
int nz; /* size of the discrete-time state */
double *z; /* vector of size nz: discrete-time state */
int nx; /* size of the continuous-time state */
double *x; /* vector of size nx: continuous-time state */
double *xd; /* vector of size nx: derivative of continuous-time state */
double *res; /* only used for internal ly implicit blocks. vector of size nx */
int nin; /* number of inputs */
int *insz; /* input sizes */
double **inptr; /* table of pointers to inputs */
int nout; /* number of outputs */
int *outsz; /* output sizes */
double **outptr;/* table of pointers to outputs */
int nevout; /* number of activation output ports */
double *evout; /* delay times of output activations */
int nrpar; /* number of real parameters */
double *rpar; /* real parameters of size nrpar */
int nipar; /* number of integer parameters */
int *ipar; /* integer parameters of size nipar */
int ng; /* number of zero-crossing surfaces */
double *g; /* zero-crossing surfaces */
int ztyp; /* boolean, true only if block MAY have zero-crossings */
int *jroot; /* vector of size ng indicating the presence and direction of crossings */
char *label; /* block label */
void **work; /* pointer to workspace if al location done by block */
int nmode; /* number of modes */
int *mode; /* mode vector of size nmode */
} scicos block;
\end{verbatim}

Voici un exemple de fonction pour le calcul des sorties~:
\begin{verbatim}
void    	camera_firewire_get_new_image(scicos_block *block)
{
  int		 i;
  static struct s_device_firewire device;
  static unsigned char rgb[3 * IMAGE_WIDTH * IMAGE_HEIGHT];

  /* block->ipar[0] <==> height */
  /* block->ipar[1] <==> width  */
  camera_firewire_get_frame(&device, rgb);
  for (i = 0; i < 3 * block->ipar[0] * block->ipar[1]; ++i)
    block->outptr[0][i] = rgb[i];
}
\end{verbatim}
%%==================================================================== 
\subsubsection*{Compilation des fonctions d'interface et de simulation}
%%==================================================================== 
Voici un script Scilab qui permet de compiler les fonctions
de simulation et de les lier aux fonctions d'interfaces.
\begin{verbatim}
// Fichier: builder.sce

comp_fun_lst = ['scicos_camera_firewire'];
c_prog_lst   = ['camera_scicos.c'];
prog_list    = strsubst(c_prog_lst, '.c', '.o');
lib_list     = ['libraw1394','libdc1394_control'];

ilib_for_link(comp_fun_lst, prog_list, lib_list, 'c');
genlib('lib_firewire', pwd());
\end{verbatim}

La variable {\tt comp\_fun\_lst} est une liste de chaîne de caractères
indiquant les noms des fonctions à utiliser. {\tt c\_prog\_lst} stocke
tous les noms des fichiers C à compiler. {\tt prog\_list} stocke les
noms des fichiers objets et dont l'extension se termine par o.
{\tt lib\_list} stocke les noms de librairies dynamiques nécessaires à
la compilation. Ces librairies se trouve dans le répertoire {\tt
  usr/lib/} et doivent être partagées (pour être ouverte lors de
l'exécution de la simulation).

Le script suivant permet de lancer la compilation et, si tout va bien,
permet de créer une palette nommée {\tt myblock.cosf}. Attention, je
n'ai pas bien compris comment créer une palette {\tt scicos\_pal}
donc il faut utiliser le menu {\tt Open as palette} pour créer une
palette valide avec le fichier {\tt myblock.cosf}.

\begin{verbatim}
exec('builder.sce');
create_palette(pwd());
load lib;
exec loader.sce;
scicos_pal($+1, ["IEEE 1394"; "myblock.cosf']);
\end{verbatim}

\dessin{figures/regulateur/scicos_camera2}{0.5}{Les fonctions d'interface et de simulation obtenues pendant une simulation.}{scicoscam2}
%%==================================================================== 
\subsubsection*{Résultat}
%%==================================================================== 
Si on doit re-modifier la fonction d'interface ou de
simulation, il faut faire attention à ce que Scilab intègre bien la
dernière version, ce qui n'est pas toujours le cas. Par exemple si on
change la fonction d'interface, on doit obligatoirement détruire le
bloc de la simulation pour en créer un nouveau, sinon l'ancienne
version ne laisse pas la place à la nouvelle.

Les figures (\ref{scicoscam}) et (\ref{scicoscam2}) montrent ce que l'on peut obtenir avec des fonctions
d'interface et de simulation.